
// ====== struct declarations ====== //
class POLYNOMIAL {
  public function evaluate: (x: integer) => integer;    
};

class LINEAR isa POLYNOMIAL {
  private attribute a: integer;
  private attribute b: integer;
  public  constructor: (A: integer, B: integer);
//  public  function evaluate: (x: integer) => integer;
  public function overload: (x: integer) => integer;
  public function overload: (x: integer,y : integer) => integer;
};



// ====== member function implementations ====== //  
function POLYNOMIAL::evaluate(x: integer) => integer                  // 2.1, 2.2
{
  return (0);                                                   // 2.3
}


function LINEAR::constructor(A: integer, B: integer)                  // 2.1, 2.2
{
  self.a = A;                                                     // 3.1, 5.3
  self.b = B;                                                     // 3.1, 5.3
}

function LINEAR::evaluate(x: integer) => integer                      // 2.1, 2.2
{
  localvar result: integer;                                         // 1.1
    result = 0;                                                 // 3.1
    result = a * x + b;                                           // 3.1, 5.1
    return (result);                                              // 2.3
  }
 function LINEAR::notImplemented(x: integer) => integer                      // 2.1, 2.2
{
  localvar result: integer;                                         // 1.1
    result = 0;                                                 // 3.1
    result = a * x + b;                                           // 3.1, 5.1
    return (result);                                              // 2.3
  }

function LINEAR::overload(x: integer,y:integer) => integer                      // 2.1, 2.2
{
  localvar result: integer;                                         // 1.1
    result = 0;                                                 // 3.1
    result = a * x + b;                                           // 3.1, 5.1
    return (result);                                              // 2.3
}
function LINEAR::overload(x: integer) => integer                      // 2.1, 2.2
{
  localvar result: integer;                                         // 1.1
    result = 0;                                                 // 3.1
    result = a * x + b;                                           // 3.1, 5.1
    return (result);                                              // 2.3
}

// cycle in class
class A isa C {};
class B isa A {};
class C isa B {};

// ====== main ====== //
function main() => void                                           // 2.1, 2.2
{
  localvar f1: LINEAR[5];                                    // 1.3, 2.1, 2.2, 2.4
  localvar f3 : LINEAR;
  localvar f2: LINEAR(14,10,4);
  localvar counter: integer;                                        // 1.1
// Duplicate declarations
  localvar counter:integer;
  counter = 1;                                                    // 3.1
// Type matching
  counter = 1+1.1;
  f1[1] = build(2,2);
  f1[2] = build(4,4);
  f3 = build(3,3);
//  f2 = build(3,4);
  write(f2.b);
  while(counter <= 10)                                            // 3.3, 5.1 
  {
    write(counter);                                               // 3.4
 //   write(f1.evaluate(counter));                                  // 3.4, 2.1, 2.2, 2.4
 //   write(f2.evaluate(counter));                                  // 3.4, 2.1, 2.2, 2.4
    counter = counter + 1;                                        // 3.1
  };
  write(f1[2].evaluate(counter,100));
  write(f3.a);
  write(f3.b);
  write(f3.evaluate(5));
  write(f2.a+counter*3+counter*(3+4));
}
