
// ====== struct declarations ====== //
class POLYNOMIAL {
  public function evaluate: (x: integer) => integer;                    
};

class LINEAR isa POLYNOMIAL {
  private attribute a: integer;
  private attribute b: integer;
  public  constructor: (A: integer, B: integer);
  public  function evaluate: (x: integer) => integer;
};



// ====== member function implementations ====== //  
function POLYNOMIAL::evaluate(x: integer) => integer                  // 2.1, 2.2
{
  return (0);                                                   // 2.3
}


function LINEAR::constructor(A: integer, B: integer)                  // 2.1, 2.2
{
  self.a = A;                                                     // 3.1, 5.3
  self.b = B;                                                     // 3.1, 5.3
}

function LINEAR::evaluate(x: integer) => integer                      // 2.1, 2.2
{
  localvar result: integer;                                         // 1.1
    result = 0;                                                 // 3.1
    result = a * x + b;                                           // 3.1, 5.1
    return (result);                                              // 2.3
  }
 
// ====== main ====== //
function main() => void                                           // 2.1, 2.2
{
  localvar f1: LINEAR[5];                                    // 1.3, 2.1, 2.2, 2.4
  localvar f2: LINEAR(14,10);
//  localvar f2: QUADRATIC(-2, 1, 0);                         // 1.3, 2.1, 2.2, 2.4
  localvar counter: integer;                                        // 1.1
  counter = 1;                                                    // 3.1
  f1[1] = build(2,2);
  f1[2] = build(4,4);
//  f2 = build(3,4);
 // write(f2.b);
  while(counter <= 10)                                            // 3.3, 5.1 
  {
    write(counter);                                               // 3.4
 //   write(f1.evaluate(counter));                                  // 3.4, 2.1, 2.2, 2.4
 //   write(f2.evaluate(counter));                                  // 3.4, 2.1, 2.2, 2.4
    counter = counter + 1;                                        // 3.1
  };
  write(f1[2].evaluate(counter));
  write(f2.a);
  write(f2.b);
  write(f2.evaluate(5));
  write(f2.a+counter*3+counter*(3+4));
}
